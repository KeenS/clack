<h1>NAME</h1><p>Clack.Middleware - Base Class for Clack Middleware. </p><h1>SYNOPSIS</h1><pre><code>(in-package :cl-user)  
(defpackage clack.middleware.example  
  (:use :cl :clack)  
  (:export :&lt;clack-middleware-example&gt;))  
(in-package :clack.middleware.example)  
 
(defclass &lt;clack-middleware-example&gt; (&lt;middleware&gt;) ())  
(defmethod call ((this &lt;clack-middleware-example&gt;) req)  
  ;; pre-processing `req'  
  (let ((res (call-next this req)))  
    ;; post-processing `res'  
    res)) </code></pre><h1>DESCRIPTION</h1><p>Clack.Middleware is the base class to write Clack Middleware. </p><p>All you have to do is to inherit from <code>&lt;middleware&gt;' and then implement the callback </code>call' method to do the actual work. </p><p>Middleware is similar to ':around' method of CLOS. You can delegate some processes to Application (or next Middleware) to call `call-next'. </p><h1>AUTHOR</h1><p>  Author: Eitarow Fukamachi (e.arrows@gmail.com) </p><h1>SEE ALSO</h1><ul><li>Clack.Component</li></ul><h1>EXTERNAL SYMBOLS</h1><ul><li><p>Class: &lt;middleware&gt; inherits (&lt;component&gt;) [app]</p><li><p>Method: call-next [(this &lt;middleware&gt;) req]</p></li></li><p>Call next middleware or application. </p><li>Method: wrap [(this &lt;middleware&gt;) app-or-middleware]</li><p>Compose this and given application or middleware instance into one function. The function takes request plist. </p></ul>